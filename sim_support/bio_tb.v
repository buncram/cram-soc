// -----------------------------------------------------------------------------
// Auto-Generated by:        __   _ __      _  __
//                          / /  (_) /____ | |/_/
//                         / /__/ / __/ -_)>  <
//                        /____/_/\__/\__/_/|_|
//                     Build your hardware, easily!
//                   https://github.com/enjoy-digital/litex
//
// Filename   : bio_tb.v
// Device     : generic
// LiteX sha1 : 45ee75db
// Date       : 2024-07-05 00:36:12
//------------------------------------------------------------------------------

`timescale 1ns / 1ps

//------------------------------------------------------------------------------
// Module
//------------------------------------------------------------------------------

module bio_tb (
    input  wire          sim_trace,
    input  wire          reset,
    input  wire          clk,
    input  wire   [31:0] test,
    output reg    [31:0] gpio_to_dut,
    input  wire   [31:0] gpio_from_dut,
    input  wire   [31:0] gpio_oe
);


//------------------------------------------------------------------------------
// Signals
//------------------------------------------------------------------------------

wire          sys_clk;
wire          sys_rst;
wire          i2c;
wire          force_1;
wire          loop_oe;
wire          invert;
wire   [15:0] force_val;
reg           i2c_scl = 1'd0;
wire          i2c_sda;
reg           i2c_scl_d = 1'd0;
reg           i2c_sda_d = 1'd0;
reg     [3:0] i2c_ctr = 4'd0;
reg     [7:0] i2c_adr_in = 8'd0;
reg     [7:0] i2c_dout = 8'd0;
reg           zero = 1'd0;
reg           i2c_sda_controller_drive_low = 1'd0;
reg           i2c_sda_peripheral_drive_low = 1'd0;
reg    [31:0] gpio_o = 32'd0;
reg    [31:0] gpio_i = 32'd0;
reg    [31:0] gpio_oe_1 = 32'd0;
reg     [2:0] state = 3'd0;
reg     [2:0] next_state = 3'd0;
reg     [3:0] i2c_ctr_next_value = 4'd0;
reg           i2c_ctr_next_value_ce = 1'd0;
reg     [7:0] i2c_adr_in_f_next_value = 8'd0;
reg           i2c_adr_in_f_next_value_ce = 1'd0;
reg     [7:0] i2c_dout_t_next_value = 8'd0;
reg           i2c_dout_t_next_value_ce = 1'd0;

//------------------------------------------------------------------------------
// Combinatorial Logic
//------------------------------------------------------------------------------

assign sys_clk = clk;
assign sys_rst = reset;
assign i2c = test[0];
assign force_1 = test[1];
assign loop_oe = test[2];
assign invert = test[3];
assign force_val = test[31:16];
assign i2c_sda = (~((i2c_sda_controller_drive_low | gpio_oe_1[2]) | i2c_sda_peripheral_drive_low));
always @(*) begin
    gpio_to_dut <= 32'd0;
    gpio_to_dut[0] <= gpio_i[0];
    gpio_to_dut[1] <= gpio_i[1];
    gpio_to_dut[2] <= gpio_i[2];
    gpio_to_dut[3] <= gpio_i[3];
    gpio_to_dut[4] <= gpio_i[4];
    gpio_to_dut[5] <= gpio_i[5];
    gpio_to_dut[6] <= gpio_i[6];
    gpio_to_dut[7] <= gpio_i[7];
    gpio_to_dut[8] <= gpio_i[8];
    gpio_to_dut[9] <= gpio_i[9];
    gpio_to_dut[10] <= gpio_i[10];
    gpio_to_dut[11] <= gpio_i[11];
    gpio_to_dut[12] <= gpio_i[12];
    gpio_to_dut[13] <= gpio_i[13];
    gpio_to_dut[14] <= gpio_i[14];
    gpio_to_dut[15] <= gpio_i[15];
    gpio_to_dut[16] <= gpio_i[16];
    gpio_to_dut[17] <= gpio_i[17];
    gpio_to_dut[18] <= gpio_i[18];
    gpio_to_dut[19] <= gpio_i[19];
    gpio_to_dut[20] <= gpio_i[20];
    gpio_to_dut[21] <= gpio_i[21];
    gpio_to_dut[22] <= gpio_i[22];
    gpio_to_dut[23] <= gpio_i[23];
    gpio_to_dut[24] <= gpio_i[24];
    gpio_to_dut[25] <= gpio_i[25];
    gpio_to_dut[26] <= gpio_i[26];
    gpio_to_dut[27] <= gpio_i[27];
    gpio_to_dut[28] <= gpio_i[28];
    gpio_to_dut[29] <= gpio_i[29];
    gpio_to_dut[30] <= gpio_i[30];
    gpio_to_dut[31] <= gpio_i[31];
end
always @(*) begin
    gpio_oe_1 <= 32'd0;
    gpio_oe_1[0] <= gpio_oe[0];
    gpio_oe_1[1] <= gpio_oe[1];
    gpio_oe_1[2] <= gpio_oe[2];
    gpio_oe_1[3] <= gpio_oe[3];
    gpio_oe_1[4] <= gpio_oe[4];
    gpio_oe_1[5] <= gpio_oe[5];
    gpio_oe_1[6] <= gpio_oe[6];
    gpio_oe_1[7] <= gpio_oe[7];
    gpio_oe_1[8] <= gpio_oe[8];
    gpio_oe_1[9] <= gpio_oe[9];
    gpio_oe_1[10] <= gpio_oe[10];
    gpio_oe_1[11] <= gpio_oe[11];
    gpio_oe_1[12] <= gpio_oe[12];
    gpio_oe_1[13] <= gpio_oe[13];
    gpio_oe_1[14] <= gpio_oe[14];
    gpio_oe_1[15] <= gpio_oe[15];
    gpio_oe_1[16] <= gpio_oe[16];
    gpio_oe_1[17] <= gpio_oe[17];
    gpio_oe_1[18] <= gpio_oe[18];
    gpio_oe_1[19] <= gpio_oe[19];
    gpio_oe_1[20] <= gpio_oe[20];
    gpio_oe_1[21] <= gpio_oe[21];
    gpio_oe_1[22] <= gpio_oe[22];
    gpio_oe_1[23] <= gpio_oe[23];
    gpio_oe_1[24] <= gpio_oe[24];
    gpio_oe_1[25] <= gpio_oe[25];
    gpio_oe_1[26] <= gpio_oe[26];
    gpio_oe_1[27] <= gpio_oe[27];
    gpio_oe_1[28] <= gpio_oe[28];
    gpio_oe_1[29] <= gpio_oe[29];
    gpio_oe_1[30] <= gpio_oe[30];
    gpio_oe_1[31] <= gpio_oe[31];
end
always @(*) begin
    gpio_o <= 32'd0;
    gpio_o[0] <= gpio_from_dut[0];
    gpio_o[1] <= gpio_from_dut[1];
    gpio_o[2] <= gpio_from_dut[2];
    gpio_o[3] <= gpio_from_dut[3];
    gpio_o[4] <= gpio_from_dut[4];
    gpio_o[5] <= gpio_from_dut[5];
    gpio_o[6] <= gpio_from_dut[6];
    gpio_o[7] <= gpio_from_dut[7];
    gpio_o[8] <= gpio_from_dut[8];
    gpio_o[9] <= gpio_from_dut[9];
    gpio_o[10] <= gpio_from_dut[10];
    gpio_o[11] <= gpio_from_dut[11];
    gpio_o[12] <= gpio_from_dut[12];
    gpio_o[13] <= gpio_from_dut[13];
    gpio_o[14] <= gpio_from_dut[14];
    gpio_o[15] <= gpio_from_dut[15];
    gpio_o[16] <= gpio_from_dut[16];
    gpio_o[17] <= gpio_from_dut[17];
    gpio_o[18] <= gpio_from_dut[18];
    gpio_o[19] <= gpio_from_dut[19];
    gpio_o[20] <= gpio_from_dut[20];
    gpio_o[21] <= gpio_from_dut[21];
    gpio_o[22] <= gpio_from_dut[22];
    gpio_o[23] <= gpio_from_dut[23];
    gpio_o[24] <= gpio_from_dut[24];
    gpio_o[25] <= gpio_from_dut[25];
    gpio_o[26] <= gpio_from_dut[26];
    gpio_o[27] <= gpio_from_dut[27];
    gpio_o[28] <= gpio_from_dut[28];
    gpio_o[29] <= gpio_from_dut[29];
    gpio_o[30] <= gpio_from_dut[30];
    gpio_o[31] <= gpio_from_dut[31];
end
always @(*) begin
    i2c_scl <= 1'd0;
    gpio_i <= 32'd0;
    if (loop_oe) begin
        gpio_i[0] <= gpio_oe_1[0];
    end else begin
        gpio_i[0] <= (gpio_o[0] ^ invert);
    end
    if (loop_oe) begin
        gpio_i[1] <= gpio_oe_1[1];
    end else begin
        gpio_i[1] <= (gpio_o[1] ^ invert);
    end
    if (i2c) begin
        gpio_i[2] <= i2c_sda;
    end else begin
        if (force_1) begin
            gpio_i[2] <= force_val[2];
        end else begin
            if (loop_oe) begin
                gpio_i[2] <= gpio_oe_1[2];
            end else begin
                gpio_i[2] <= (gpio_o[2] ^ invert);
            end
        end
    end
    if (i2c) begin
        gpio_i[3] <= (~gpio_oe_1[3]);
        i2c_scl <= (~gpio_oe_1[3]);
    end else begin
        if (force_1) begin
            gpio_i[3] <= force_val[3];
        end else begin
            if (loop_oe) begin
                gpio_i[3] <= gpio_oe_1[3];
            end else begin
                gpio_i[3] <= (gpio_o[3] ^ invert);
            end
        end
    end
    if (loop_oe) begin
        gpio_i[4] <= gpio_oe_1[4];
    end else begin
        gpio_i[4] <= (gpio_o[4] ^ invert);
    end
    if (loop_oe) begin
        gpio_i[5] <= gpio_oe_1[5];
    end else begin
        gpio_i[5] <= (gpio_o[5] ^ invert);
    end
    if (loop_oe) begin
        gpio_i[6] <= gpio_oe_1[6];
    end else begin
        gpio_i[6] <= (gpio_o[6] ^ invert);
    end
    if (loop_oe) begin
        gpio_i[7] <= gpio_oe_1[7];
    end else begin
        gpio_i[7] <= (gpio_o[7] ^ invert);
    end
    if (loop_oe) begin
        gpio_i[8] <= gpio_oe_1[8];
    end else begin
        gpio_i[8] <= (gpio_o[8] ^ invert);
    end
    if (loop_oe) begin
        gpio_i[9] <= gpio_oe_1[9];
    end else begin
        gpio_i[9] <= (gpio_o[9] ^ invert);
    end
    if (loop_oe) begin
        gpio_i[10] <= gpio_oe_1[10];
    end else begin
        gpio_i[10] <= (gpio_o[10] ^ invert);
    end
    if (loop_oe) begin
        gpio_i[11] <= gpio_oe_1[11];
    end else begin
        gpio_i[11] <= (gpio_o[11] ^ invert);
    end
    if (loop_oe) begin
        gpio_i[12] <= gpio_oe_1[12];
    end else begin
        gpio_i[12] <= (gpio_o[12] ^ invert);
    end
    if (loop_oe) begin
        gpio_i[13] <= gpio_oe_1[13];
    end else begin
        gpio_i[13] <= (gpio_o[13] ^ invert);
    end
    if (loop_oe) begin
        gpio_i[14] <= gpio_oe_1[14];
    end else begin
        gpio_i[14] <= (gpio_o[14] ^ invert);
    end
    if (loop_oe) begin
        gpio_i[15] <= gpio_oe_1[15];
    end else begin
        gpio_i[15] <= (gpio_o[15] ^ invert);
    end
    if (force_1) begin
        gpio_i[16] <= force_val[0];
    end else begin
        if (loop_oe) begin
            gpio_i[16] <= gpio_oe_1[16];
        end else begin
            gpio_i[16] <= (gpio_o[16] ^ invert);
        end
    end
    if (force_1) begin
        gpio_i[17] <= force_val[1];
    end else begin
        if (loop_oe) begin
            gpio_i[17] <= gpio_oe_1[17];
        end else begin
            gpio_i[17] <= (gpio_o[17] ^ invert);
        end
    end
    if (force_1) begin
        gpio_i[18] <= force_val[2];
    end else begin
        if (loop_oe) begin
            gpio_i[18] <= gpio_oe_1[18];
        end else begin
            gpio_i[18] <= (gpio_o[18] ^ invert);
        end
    end
    if (force_1) begin
        gpio_i[19] <= force_val[3];
    end else begin
        if (loop_oe) begin
            gpio_i[19] <= gpio_oe_1[19];
        end else begin
            gpio_i[19] <= (gpio_o[19] ^ invert);
        end
    end
    if (force_1) begin
        gpio_i[20] <= force_val[4];
    end else begin
        if (loop_oe) begin
            gpio_i[20] <= gpio_oe_1[20];
        end else begin
            gpio_i[20] <= (gpio_o[20] ^ invert);
        end
    end
    if (force_1) begin
        gpio_i[21] <= force_val[5];
    end else begin
        if (loop_oe) begin
            gpio_i[21] <= gpio_oe_1[21];
        end else begin
            gpio_i[21] <= (gpio_o[21] ^ invert);
        end
    end
    if (force_1) begin
        gpio_i[22] <= force_val[6];
    end else begin
        if (loop_oe) begin
            gpio_i[22] <= gpio_oe_1[22];
        end else begin
            gpio_i[22] <= (gpio_o[22] ^ invert);
        end
    end
    if (force_1) begin
        gpio_i[23] <= force_val[7];
    end else begin
        if (loop_oe) begin
            gpio_i[23] <= gpio_oe_1[23];
        end else begin
            gpio_i[23] <= (gpio_o[23] ^ invert);
        end
    end
    if (force_1) begin
        gpio_i[24] <= force_val[8];
    end else begin
        if (loop_oe) begin
            gpio_i[24] <= gpio_oe_1[24];
        end else begin
            gpio_i[24] <= (gpio_o[24] ^ invert);
        end
    end
    if (force_1) begin
        gpio_i[25] <= force_val[9];
    end else begin
        if (loop_oe) begin
            gpio_i[25] <= gpio_oe_1[25];
        end else begin
            gpio_i[25] <= (gpio_o[25] ^ invert);
        end
    end
    if (force_1) begin
        gpio_i[26] <= force_val[10];
    end else begin
        if (loop_oe) begin
            gpio_i[26] <= gpio_oe_1[26];
        end else begin
            gpio_i[26] <= (gpio_o[26] ^ invert);
        end
    end
    if (force_1) begin
        gpio_i[27] <= force_val[11];
    end else begin
        if (loop_oe) begin
            gpio_i[27] <= gpio_oe_1[27];
        end else begin
            gpio_i[27] <= (gpio_o[27] ^ invert);
        end
    end
    if (force_1) begin
        gpio_i[28] <= force_val[12];
    end else begin
        if (loop_oe) begin
            gpio_i[28] <= gpio_oe_1[28];
        end else begin
            gpio_i[28] <= (gpio_o[28] ^ invert);
        end
    end
    if (force_1) begin
        gpio_i[29] <= force_val[13];
    end else begin
        if (loop_oe) begin
            gpio_i[29] <= gpio_oe_1[29];
        end else begin
            gpio_i[29] <= (gpio_o[29] ^ invert);
        end
    end
    if (force_1) begin
        gpio_i[30] <= force_val[14];
    end else begin
        if (loop_oe) begin
            gpio_i[30] <= gpio_oe_1[30];
        end else begin
            gpio_i[30] <= (gpio_o[30] ^ invert);
        end
    end
    if (force_1) begin
        gpio_i[31] <= force_val[15];
    end else begin
        if (loop_oe) begin
            gpio_i[31] <= gpio_oe_1[31];
        end else begin
            gpio_i[31] <= (gpio_o[31] ^ invert);
        end
    end
end
always @(*) begin
    i2c_adr_in_f_next_value <= 8'd0;
    i2c_adr_in_f_next_value_ce <= 1'd0;
    next_state <= 3'd0;
    i2c_sda_controller_drive_low <= 1'd0;
    i2c_sda_peripheral_drive_low <= 1'd0;
    i2c_ctr_next_value <= 4'd0;
    i2c_ctr_next_value_ce <= 1'd0;
    i2c_dout_t_next_value <= 8'd0;
    i2c_dout_t_next_value_ce <= 1'd0;
    next_state <= state;
    case (state)
        1'd1: begin
            if ((((i2c_sda_d & (~i2c_sda)) & i2c_scl) & i2c_scl_d)) begin
                i2c_ctr_next_value <= 4'd8;
                i2c_ctr_next_value_ce <= 1'd1;
                next_state <= 1'd1;
            end else begin
                if (((((~i2c_sda_d) & i2c_sda) & i2c_scl) & i2c_scl_d)) begin
                    next_state <= 1'd0;
                end else begin
                    if ((i2c_scl & (~i2c_scl_d))) begin
                        i2c_ctr_next_value <= (i2c_ctr - 1'd1);
                        i2c_ctr_next_value_ce <= 1'd1;
                        if ((i2c_ctr != 1'd0)) begin
                            i2c_adr_in_f_next_value <= {i2c_adr_in[6:0], i2c_sda};
                            i2c_adr_in_f_next_value_ce <= 1'd1;
                        end
                    end else begin
                        if (((~i2c_scl) & i2c_scl_d)) begin
                            if ((i2c_ctr == 1'd0)) begin
                                next_state <= 2'd2;
                            end
                        end
                    end
                end
            end
        end
        2'd2: begin
            if ((i2c_adr_in != 5'd23)) begin
                i2c_sda_peripheral_drive_low <= 1'd1;
            end
            if (((((~i2c_sda_d) & i2c_sda) & i2c_scl) & i2c_scl_d)) begin
                next_state <= 1'd0;
            end else begin
                if (((~i2c_scl) & i2c_scl_d)) begin
                    i2c_dout_t_next_value <= (~i2c_adr_in);
                    i2c_dout_t_next_value_ce <= 1'd1;
                    if ((i2c_adr_in != 5'd23)) begin
                        i2c_ctr_next_value <= 4'd8;
                        i2c_ctr_next_value_ce <= 1'd1;
                        if (i2c_adr_in[0]) begin
                            next_state <= 2'd3;
                        end else begin
                            next_state <= 1'd1;
                        end
                    end else begin
                        next_state <= 1'd0;
                    end
                end
            end
        end
        2'd3: begin
            if (((((~i2c_sda_d) & i2c_sda) & i2c_scl) & i2c_scl_d)) begin
                next_state <= 1'd0;
            end else begin
                if (((~i2c_scl) & i2c_scl_d)) begin
                    i2c_ctr_next_value <= (i2c_ctr - 1'd1);
                    i2c_ctr_next_value_ce <= 1'd1;
                    if ((i2c_ctr != 1'd0)) begin
                        i2c_dout_t_next_value <= {i2c_dout[6:0], zero};
                        i2c_dout_t_next_value_ce <= 1'd1;
                    end
                end else begin
                    if ((i2c_scl & (~i2c_scl_d))) begin
                        if ((i2c_ctr == 1'd0)) begin
                            next_state <= 3'd4;
                        end
                    end
                end
            end
            i2c_sda_controller_drive_low <= (~i2c_dout[7]);
        end
        3'd4: begin
            if (((((~i2c_sda_d) & i2c_sda) & i2c_scl) & i2c_scl_d)) begin
                next_state <= 1'd0;
            end else begin
                if (((~i2c_scl) & i2c_scl_d)) begin
                    next_state <= 1'd0;
                end
            end
        end
        default: begin
            if ((((i2c_sda_d & (~i2c_sda)) & i2c_scl) & i2c_scl_d)) begin
                i2c_ctr_next_value <= 4'd8;
                i2c_ctr_next_value_ce <= 1'd1;
                next_state <= 1'd1;
            end
        end
    endcase
end


//------------------------------------------------------------------------------
// Synchronous Logic
//------------------------------------------------------------------------------

always @(posedge sys_clk) begin
    i2c_sda_d <= i2c_sda;
    i2c_scl_d <= i2c_scl;
    state <= next_state;
    if (i2c_ctr_next_value_ce) begin
        i2c_ctr <= i2c_ctr_next_value;
    end
    if (i2c_adr_in_f_next_value_ce) begin
        i2c_adr_in <= i2c_adr_in_f_next_value;
    end
    if (i2c_dout_t_next_value_ce) begin
        i2c_dout <= i2c_dout_t_next_value;
    end
    if (sys_rst) begin
        i2c_scl_d <= 1'd0;
        i2c_sda_d <= 1'd0;
        i2c_ctr <= 4'd0;
        i2c_adr_in <= 8'd0;
        i2c_dout <= 8'd0;
        state <= 3'd0;
    end
end


//------------------------------------------------------------------------------
// Specialized Logic
//------------------------------------------------------------------------------

endmodule

// -----------------------------------------------------------------------------
//  Auto-Generated by LiteX on 2024-07-05 00:36:12.
//------------------------------------------------------------------------------
